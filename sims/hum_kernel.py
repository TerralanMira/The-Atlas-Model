#!/usr/bin/env python3
"""
Hum Kernel — reference layer that couples observation, stability and memory to a simulation.

Use: import and call `apply_hum_controls(...)` each step inside any sim loop.
Also logs lightweight diagnostics to JSONL for post-run analysis.

This module is self-contained; it does not change equations of motion directly.
It only returns controls (sigma_eff, coupling_bias, memory_mix).
"""

from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
import json, math, time
import numpy as np

# -------- Parameters --------
@dataclass
class HumParams:
    rho: float = 0.6   # observation in [0,1+]; higher -> lower effective noise
    lam: float = 0.15  # ethics/stability in [0, ~1]; small bias toward mean phase
    mu: float  = 0.5   # memory mix in [0,1]; EMA of state features
    log: bool  = True  # write JSONL diagnostics
    run_id: str = None # optional id; autogenerated if None

# -------- State container (minimal) --------
@dataclass
class SimSnapshot:
    step: int
    dt: float
    phases: np.ndarray   # shape (n,), radians
    natural: np.ndarray  # shape (n,), ω
    order_R: float       # global order parameter magnitude in [0,1]
    order_psi: float     # global mean phase angle

# -------- Kernel application --------
def apply_hum_controls(p: HumParams, snap: SimSnapshot) -> dict:
    # Effective noise: σ * exp(-ρ) — monotone reduction with observation
    # Guard against negative or extreme values:
    rho = max(0.0, float(p.rho))
    lam = max(0.0, float(p.lam))
    mu  = min(1.0, max(0.0, float(p.mu)))

    # Coherence-adaptive damping: stronger when R is high (protect coherence),
    # lighter when R is low (allow exploration)
    adapt = 0.25 + 0.75 * snap.order_R   # ∈ [0.25, 1.0]
    sigma_scale = math.exp(-rho * adapt)

    # Small stabilizing pull toward mean phase (ethics-as-coherence)
    # scale with lam and coherence
    coupling_bias = lam * snap.order_R

    out = {
        "sigma_eff_scale": sigma_scale,  # multiply base σ by this
        "coupling_bias": coupling_bias,  # add to K * sin(ψ - θ)
        "memory_mix": mu,
        "notes": {
            "rho": rho, "lam": lam, "mu": mu,
            "R": float(snap.order_R), "psi": float(snap.order_psi),
            "adapt": adapt
        }
    }

    if p.log:
        _log_kernel(p, snap, out)

    return out

# -------- Logging --------
def _log_kernel(p: HumParams, snap: SimSnapshot, out: dict):
    root = Path("sims/out"); root.mkdir(parents=True, exist_ok=True)
    rid = p.run_id or f"hum_{int(time.time())}"
    path = root / f"{rid}.jsonl"
    rec = {
        "step": snap.step,
        "dt": snap.dt,
        **out["notes"],
        "sigma_eff_scale": out["sigma_eff_scale"],
        "coupling_bias": out["coupling_bias"],
        "memory_mix": out["memory_mix"],
    }
    with path.open("a", encoding="utf-8") as f:
        f.write(json.dumps(rec) + "\n")
